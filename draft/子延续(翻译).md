[原文](http://www.cs.indiana.edu/~dyb/pubs/LaSC-7-1-pp83-110.pdf)

摘要.延续已经被证明是一种用于实现包括异常处理和广度优先搜索等控制结构的有效设施.但是传统的延续在并发的场景下并不是十分有用.因为在并发场景下,延续所代表的概念:剩余的计算过程,并不一定是有意义的.传统延续在非并发场景下也非常难以使用,因为它全局的性质有时候会带来问题.本文展示了一种新的延续类型,子延续.如传统延续所代表的在一个计算过程中从某位置开始的剩余的计算过程,子延续代表了在一个子计算过程中某位置开始的剩余的子计算过程.子延续可以被用于控制树形结构的并发,它使得我们可以非局部跳转到过程树中的任意一个点上并且可以把一棵子树的计算作为一个合成延续捕获以供后续使用.即使在非并发的场景下,局部化的控制也使得子延续比传统延续更有用.


### 1 介绍

延续是一种抽象实体,用以表示一个完整的计算过程中,从某位置开始的,余下的计算过程.例如,Scheme语言提供了将延续作为第一类型值访问的手段,这使得它无须再提供对循环,goto,异常处理,协程等传统的命令式语言的控制结构.这样不但简化了语言的设计,同时让程序员可以创建一些语言设计者无法预料的新控制结构.

但是,传统的延续在并法场景下存在一些问题.因为在并发场景下,延续所代表的概念:剩余的计算过程,并不一定是有意义的.
当我们将传统延续应用到树形结构的并发操作符上,例如并行调用操作符(`parallel call operator`),我们必须决定当前延续所代表的剩余计算是否包括过程树的根,又或者只包含当前过程的剩余计算(当前过程处于叶节点).没有那种方法可以适合所有的情况.将延续的使用限制在过程树的叶节点将会导致异常处理变得困难,因为这个异常可能需要从当前节点回溯到根节点.另一方面如果不将控制局限在叶子节点,那么在叶子节点上使用非局部退出或其它基于延续的控制结构又变得非常困难.
更进一步的,没有一种方法允许我们将处理树中的一部分作为单独的单元,也就是说我们无法从处理树的任意一棵子树中退出,也无法使用延续来保存任意一棵子树的状态.我们需要一种方法来指定一个延续在过程树中包含的范围.

传统延续在非并发场景下也很难正确的使用,因为它的全局特性经常会导致我们没预料到的非局部影响.例如,挂起一个子计算过程,在将来某个时刻从一个不同的延续C中重启被挂起的子计算过程,并确保当子计算过程结束之后返回到延续C是十分困难的.实现这个需求需要捕获一个看似多余的延续,并通过调用这个延续来执行返回.这再次说明我们需要一种方法来指定延续中应该包含哪些计算内容.

在本文中我们描述了一种新的延续类型,子延续,它使得我们可以实现我们的需求.如传统延续所代表的在一个计算过程中从某位置开始的剩余的计算过程,子延续代表了在一个子计算过程中某位置开始的剩余的子计算过程.因此,子延续无论在并发还是非并发的场景下都比传统延续更加有用.子延续提供了对树形过程处理的完全控制手段,使得我们可以非局部退出到过程树中的任意一点,将子树的计算过程捕获成组合延续以供后续使用.对于并发场景,子延续使得我们可以将控制操作的产生的影响局部化.

并非所有的并发处理都是基于树形结构的.树形并发与其它并发形式的区别可以参考Halstead’s Multilisp [1],里面描述了并行调用(parallel calls)和期货(futures)这两种不同的并发处理方式.`pcall`提供了一种基于树形结构的并发处理,它首先并行的将传递给它的参数求值,然后将第一个参数应用到其它参数上(第一个参数是一个过程,将这个过程应用到剩余参数求出的值上).而另一方面,期货方式创建了一个不返回任何值的并行处理进程.当我们需要结果的时候去询处理进程结果是否已经准备好.在并行过程的创建点上是否会返回值把树形并发处理和期货式并发处理的主要区别.其它基于树形并发处理的例子是参考McCarthy’s `amb`操作符 [20]或类似的并行`and`和`or`操作符.虽然我们的机制(子延续)并没有应用于非树形并发处理,但我们还是会讨论如何在支持这两种并发形式的语言中使用我们的机制.

本文的余下部分被组织成以下形式.在章节2中我们会讨论传统延续的控制策略和一些新的延续控制机制,并讨论子延续如何解决这些策略所存在的问题.在章节3和4,我们引进子延续并介绍在并发和顺序执行的场景下它如何控制子计算过程.在章节5中我们将介绍控制过滤器(control filters).它是一种类似于Common Lisp中`unwind-protect`和Scheme中`dynamic-wind`的控制结构,以使得我们可以指定处理过程入口和出口处理器的控制机制.在章节6中我们将描述`engines`的一种实现,通过应用子延续和控制过滤器它提供了多任务处理的能力.在章节7中我们将展示一个添加了
子延续,赋值及控制过滤扩展的基于变量传值调用的λ-演算的操作语义.在章节8中我们将介绍如何实现子延续.最后我们将在章节9做出总结.

### 2 背景知识
Continuations are commonly used in denotational semantics as a basis for deriving the meaning of control operations in imperative languages [25].很多程序设计语言都提供了像`jumps`和`exits`这样的控制指令用于改变当前程序的延续.Scheme语言提供了`all-with-current-continuation`(缩写形式为call/cc)方法用于捕获当前延续,这个捕获到的延续以过程(函数)的形式表现,可以直接调用.The application (call/cc p) causes p to be applied to a procedure representing the current continuation.当通过call/cc捕获到的延续被应用到一个值,程序的执行流程将回到`call/cc`被调用的地方继续执行,且那个值将被作为`call/cc`的返回值,例如表达式

    (call/cc (lambda (k ) (+ (k 0) 1)))
    
求值为0.

假设我们要求一个list中所有元素的乘积,为了避免当list中有0元素而导致额外的乘法运算.我们可以这样做,递归遍历list,当到达list尾部的时候才回溯执行乘法运算.如果在到达尾部前发现0元素则直接返回0终止过程:

    (define product0
        (lambda (ls exit )
            (cond
                ((null? ls ) 1)
                ((= (car ls ) 0) (exit 0))
                (else (∗ (car ls ) (product0 (cdr ls ) exit ))))))

使用`call/cc`为`product0`提供一个合适的延续以作为`exit`调用:

(define product
    (lambda (ls )
        (call/cc
            (lambda (exit )
                (product 0 ls exit )))))
                
在并发的场景下,即使这么简单的应用的延续场景都会产生一定的困难.假设我们要将两个list的乘积求和:

    (+ (product list 1 ) (product list 2 ))

`product`内部的实现是否使用了`call/cc`不应该被使用它的程序员关心.但是在一个并发系统中问题就变得没那么简单.假设有一个方法`pcall`可以让列表求积的运算并发执行:

    (pcall + (product list 1 ) (product list 2 ))

                




