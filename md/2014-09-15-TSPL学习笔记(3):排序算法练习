####快速排序

快排的详细介绍[见](http://zh.wikipedia.org/zh/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F),简单的说就是取输入序列中的首元素m,然后将除首元素m以外的其它元素分成两组,小于等于m的一组和大于m的一组.将3组元素组合成输入队列:小于等于m + m + 大于m.

下面看一个用haskell实现的快速排序代码:

    quicksort :: (Ord a) => [a] -> [a]   
    quicksort [] = []   
    quicksort (x:xs) =   
      let smallerSorted = quicksort [a | a <- xs, a <= x]  
          biggerSorted = quicksort [a | a <- xs, a > x]   
      in smallerSorted ++ [x] ++ biggerSorted

haskell中有列表解析(List Comprehension)的支持,所以`smallerSorted`和`biggerSorted`两个集合通过列表解析很方便的就生成了.而Scheme中没有列表解析,所以首先要实现一个类似列表解析的功能将附后条件的列表元素筛选出来:


    (define my-filter
        (lambda (f l)	
            (define iter
                (lambda (l a)
                    (if (not (pair? l)) a
                        (let* ([h (car l)] [r (if (f h) (append a (list h)) a)])
                                (iter (cdr l) r)))))
            (iter l '())))
            
filter的功能是输入一个条件判断函数f和一个列表l,filter将l中所有满足f的元素组成一个列表并返回.上面代码使用的是`accumulator`模式,也就是在迭代模式,通过传进一个a参数在每次递归调用中保存结果.可以注意到这个filter的定义是满足尾递归的.

下面是filter的递归版本:

    (define my-filter
        (lambda (f l)
            (if (not (pair? l)) '()
                (let ([h (car l)])
                    (if (f h) (cons h (filter f (cdr l)))
        (filter f (cdr l)))))))
                        
通过cps变换将上述函数转换成尾递归的:

    (define my-filter
        (lambda (f l)
            (define cps
                (lambda (l k)
                    (if (not (pair? l)) (k '())
                        (let ([h (car l)])
                            (if (f h) (cps (cdr l) (lambda (x) (k (cons h x))))
                                (cps (cdr l) (lambda (x) (k x))))))))
        (cps l (lambda (x) x))))
                        


有了filter之后我们就可以实现qsort了:

    (define qsort
        (lambda (l)
            (if (not (pair? l)) '()
                (let* ([m (car l)]
                       [large (my-filter (lambda (x) (if (> x m) #t #f)) (cdr l))]
                       [less (my-filter (lambda (x) (if (<= x m) #t #f)) (cdr l))])
                (append (qsort less) (cons m (qsort large)))))))
                
    >(qsort `(5 1 4 2 3 3 7)) -> (1 2 3 3 4 5 7)


比较下与haskell版的区别,首先是没有列表解析,其次是没有模式匹配,需要用if表达式处理.

当然haskell中也是由filter的,下面就是haskell快排的filter版本:

    quicksort :: (Ord a) => [a] -> [a]     
    quicksort [] = []     
    quicksort (x:xs) =      
        let smallerSorted = quicksort (filter (<=x) xs) 
            biggerSorted = quicksort (filter (>x) xs)    
        in  smallerSorted ++ [x] ++ biggerSorted



####冒泡排序

冒泡排序的详细介绍[见](http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)

