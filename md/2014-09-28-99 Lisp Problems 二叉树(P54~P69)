P54A (*) Check whether a given term represents a binary tree
Write a predicate istree which returns true if and only if its argument is a list representing a binary tree.

Example:

(istree (a (b nil nil) nil))

T

(istree (a (b nil nil)))

NIL


    (define (istree tree)
        (if (or (eq? 'nil tree) (null? tree)) #t ;empty is a tree
            (if (not (= (length tree) 3)) #f;
                (let ([root (not (pair? (car tree)))]
                      [left (istree (cadr tree))]
                      [right (istree (caddr tree))])
                 (and root left right)))))
                 

P55 (**) Construct completely balanced binary trees
In a completely balanced binary tree, the following property holds for every node: 
The number of nodes in its left subtree and the number of nodes in its right subtree are almost equal, 
which means their difference is not greater than one.

Write a function cbal-tree to construct completely balanced binary trees for a given number of nodes. 
The predicate should generate all solutions via backtracking. Put the letter 'x' as information into all 
nodes of the tree.
Example:

cbal-tree(4,T).

T = t(x, t(x, nil, nil), t(x, nil, t(x, nil, nil))) ;

T = t(x, t(x, nil, nil), t(x, t(x, nil, nil), nil)) ;

etc......No

构造完全平衡二叉树,完全平衡二叉树的定义是左右子树的节点数量相差不超过1。

算法执行步骤:

构造节点数量为(n - 1)/2的完全平衡树集合s1

构造节点数量为n - (n - 1)/2的完全平衡树集合s2

从s1中取元素作为左子树,从s2中取元素作为右子树.

如果s1 != s2

从s2中取元素作为左子树,从s1中取元素作为右子树.


    (define (cbal-tree n)
        (define (iter n result)
            (if (<= n 0) '(nil)
                (let* ([n1 (floor (/ (- n 1) 2))] 
                       [n2 (- (- n 1) n1)]
                       [sub1 (iter n1 result)]
                       [sub2 (iter n2 result)]
                       [r (if (not (equal? sub1 sub2))
                              (foldr (lambda (x1 acc1) 
                                        (append (foldr (lambda (x2 acc2)
                                            (cons (list 'x x1 x2) acc2)) '() sub2) acc1))
                                     '() sub1) '() )])            
                        (append r (append (foldr (lambda (x1 acc1) 
                                            (append (foldr (lambda (x2 acc2)
                                                (cons (list 'x x2 x1) acc2)) '() sub2) acc1))
                       '() sub1) result)))))
        (iter n '()))	
        
        
P56 (**) Symmetric binary trees
Let us call a binary tree symmetric if you can draw a vertical line through the root 
node and then the right subtree is the mirror image of the left subtree. Write a predicate 
symmetric/1 to check whether a given binary tree is symmetric. Hint: Write a predicate mirror/2 
first to check whether one tree is the mirror image of another. We are only interested in the 
structure, not in the contents of the nodes.        

    (define (sametree? tree1 tree2)
        (cond [(or (and (pair? tree1) (not (pair? tree2)))
                   (and (pair? tree2) (not (pair? tree1)))) #f]
              [(and (eq? 'nil tree1) (eq? 'nil tree2)) #t]     
              [else (and (sametree? (cadr tree1) (cadr tree2)) (sametree? (caddr tree1) (caddr tree2)))]))

    (define (mirror? tree1 tree2);tree1的左子树结构==tree2的右子树且tree1的右子树结构==tree2的左子树则两树是镜像
        (and (sametree? (cadr tree1) (caddr tree2)) (sametree? (caddr tree1) (cadr tree2))))			

    (define (symmetric tree) (mirror? (cadr tree) (caddr tree)))
    
P57 (**) Binary search trees (dictionaries)
Use the predicate add/3, developed in chapter 4 of the course, 
to write a predicate to construct a binary search tree from a list of integer numbers.

Example:

construct([3,2,5,7,1],T).

T = t(3, t(2, t(1, nil, nil), nil), t(5, nil, t(7, nil, nil)))

Then use this predicate to test the solution of the problem P56.

Example:

test-symmetric([5,3,18,1,4,12,21]).

Yes

test-symmetric([3,2,5,7,1]).

No 


    (define (construct xs)
        (define (add x tree)
            (if (or (null? tree) (eq? 'nil tree)) (list x 'nil 'nil)
                (if (> x (car tree)) (list (car tree) (cadr tree) (add x (caddr tree)))
                    (list (car tree) (add x (cadr tree)) (caddr tree)))))	
        (define (iter xs tree)
            (if (null? xs) tree
                (iter (cdr xs) (add (car xs) tree))))
        (iter xs '()))
        
P58 (**) Generate-and-test paradigm
Apply the generate-and-test paradigm to construct all symmetric, 
completely balanced binary trees with a given number of nodes. Example:

sym-cbal-trees(5,Ts).

Ts = [t(x, t(x, nil, t(x, nil, nil)), t(x, t(x, nil, nil), nil)), t(x, t(x, t(x, nil, nil), nil), t(x, nil, t(x, nil, nil)))] 

How many such trees are there with 57 nodes? Investigate about how many solutions there are for a given number of nodes? 
What if the number is even? Write an appropriate predicate.        



    (define (sym-cbal-trees n)
        (let ([trees (cbal-tree n)])
             (foldr (lambda (x acc) (if (symmetric x) (cons x acc) acc))
                    '() trees)))
                    
                    
P59 (**) Construct height-balanced binary trees
In a height-balanced binary tree, the following property holds for every node: 
The height of its left subtree and the height of its right subtree are almost equal,
 which means their difference is not greater than one.

Write a predicate hbal-tree/2 to construct height-balanced binary trees for a given height.
The predicate should generate all solutions via backtracking. Put the letter 'x' as information 
into all nodes of the tree.

Example:

hbal-tree(3,T).

T = t(x, t(x, t(x, nil, nil), t(x, nil, nil)), t(x, t(x, nil, nil), t(x, nil, nil))) ;

T = t(x, t(x, t(x, nil, nil), t(x, nil, nil)), t(x, t(x, nil, nil), nil)) ;

etc......No

    (define (hbal-tree h)
        ;高度为2的高度平衡树只有
        ;   x          x          x
        ; x  nil    nil  x     x     x
        ;三种  
        (cond [(= 1 h) (list '(x nil nil))]
              [(= 2 h) (list '(x (x nil nil) nil) '(x nil (x nil nil)) '(x (x nil nil) (x nil nil)))] 
              [else (let* ([sub1 (hbal-tree (- h 1))] ;所有高度为h-1的子树
                           [sub2 (hbal-tree (- h 2))] ;所有高度为h-2的子树		  			   
                           [t1 (foldr (lambda (x1 acc1) 
                                (append (foldr (lambda (x2 acc2)
                                     (cons (list 'x x2 x1) acc2)) '() sub1) acc1)) '() sub2)]
                           [t2 (foldr (lambda (x1 acc1) 
                                (append (foldr (lambda (x2 acc2)
                                        (cons (list 'x x1 x2) acc2)) '() sub1) acc1)) '() sub2)]
                           [t3 (foldr (lambda (x1 acc1) 
                                (append (foldr (lambda (x2 acc2)
                                     (cons (list 'x x2 x1) acc2)) '() sub1) acc1)) '() sub1)])		  							
                           (append t1 t2 t3))]))
                           
                           
                           